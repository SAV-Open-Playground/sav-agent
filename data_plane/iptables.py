# -*- coding: utf-8 -*-
"""
-------------------------------------------------
   File Name:     iptables.py
   Description :
   Author :       MichaelYoung
   date:          2023/12/27
-------------------------------------------------
   Change Activity:
                   2023/12/27:
-------------------------------------------------
"""
import os
import subprocess
from common.sav_common import get_host_interface_list
from common.logger import LOGGER as logger

SAV_CHAIN = "SAVAGENT"
LOG_DIR = "/root/savop/logs"


class IPTableManager():
    """
    generate iptables rules and apply them
    """

    def __init__(self):
        """
        the rule generated by all apps will be added to DB,
        but only the rule generated by the active app will be applied via iptables or traffic control(tc) tools
        """
        self.sav_rules = {}
        create_chain_status = subprocess.call(['iptables', '-N', SAV_CHAIN])
        if create_chain_status != 0:
            return
        input_status = subprocess.call(['iptables', '-I', 'INPUT', '-j', SAV_CHAIN])
        forward_status = subprocess.call(['iptables', '-I', 'FORWARD', '-j', SAV_CHAIN])
        create_chain_status = subprocess.call(['ip6tables', '-N', SAV_CHAIN])
        if create_chain_status != 0:
            return
        input_status = subprocess.call(['ip6tables', '-I', 'INPUT', '-j', SAV_CHAIN])
        forward_status = subprocess.call(['ip6tables', '-I', 'FORWARD', '-j', SAV_CHAIN])
        # init tc tool's qdisc, class, filter
        interface_list = get_host_interface_list()
        for index in range(0, len(interface_list)):
            init_tc_command = f"tc qdisc add dev {interface_list[index]} root handle 1: htb default 20 && " \
                              f"tc class add dev {interface_list[index]} parent 1:0 classid 1:1 htb rate 3Mbit && " \
                              f"tc filter add dev {interface_list[index]} parent 1:0 prio 1 protocol ip handle {str(index + 1)} fw flowid 1:1"
            init_tc_status = self._command_executor(command=init_tc_command)

    def _command_executor(self, command):
        command_result = subprocess.run(command, shell=True, capture_output=True, encoding='utf-8')
        return command_result.returncode

    def enable(self, rules, active_app):
        ipv4_rules, ipv6_rules = self._separate_v4_and_v6_addr(rules=rules)
        self._enable_ipv4(rules=ipv4_rules, active_app=active_app)
        self._enable_ipv6(rules=ipv6_rules, active_app=active_app)
        log_info = f"refresh iptables {active_app} successfully"
        logger.info(log_info)
        return None

    def _separate_v4_and_v6_addr(self, rules):
        ipv4_addr_dict, ipv6_addr_dict = {}, {}
        for k, v in rules.items():
            if v["prefix"].version == 4:
                ipv4_addr_dict.update({k:v})
            else:
                ipv6_addr_dict.update({k:v})
        return ipv4_addr_dict, ipv6_addr_dict

    def _enable_ipv4(self, rules, active_app):
        flush_chain_status = subprocess.call(['iptables', '-F', SAV_CHAIN])
        if flush_chain_status != 0:
            logger.error(f"flush ip4tables failed")
        interface_set = set(get_host_interface_list())
        # store iptables
        store_init_filer_talbes_commmand = f"iptables-save -t filter > {LOG_DIR}/ip4tables_filter_rule.txt"
        command_status = self._command_executor(command=store_init_filer_talbes_commmand)
        filter_rules = ""
        container_id = os.environ.get("HOSTNAME")
        if active_app not in ["EFP-uRPF-Algorithm-A_app", "EFP-uRPF-Algorithm-B_app"]:
            for r in list(rules.values()):
                ip_addr, prefixlen, interface_name = str(r["prefix"].ip), r["prefix"].prefixlen, set((r["interface_name"],))
                for interface in interface_set - interface_name:
                    log_line = f'-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface} -j LOG --log-prefix \"IPTABLES {container_id} DROP: \" --log-level 7' + "\n"
                    line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface} -j DROP"
                    filter_rules = filter_rules + log_line  + line + "\n"
            with open(f"{LOG_DIR}/ip4tables_filter_rule.txt", "r") as f:
                lines = f.readlines()[:-2]
            content = ""
            for line in lines:
                content = content + line
            content = content + filter_rules + "COMMIT\n"
            with open(f"{LOG_DIR}/ip4tables_filter_rule.txt", 'w') as f:
                f.write(content)
            apply_filer_talbes_commmand = f"iptables-restore < {LOG_DIR}/ip4tables_filter_rule.txt"
            command_status = self._command_executor(command=apply_filer_talbes_commmand)
        # using white list mode for EFP-uRPF
        elif active_app in ["EFP-uRPF-Algorithm-A_app", "EFP-uRPF-Algorithm-B_app"]:
            for r in list(rules.values()):
                ip_addr, prefixlen, interface_name = str(r["prefix"].ip), r["prefix"].prefixlen, r["interface_name"]
                line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface_name} -j ACCEPT"
                filter_rules = filter_rules + line + "\n"
            line = f"-A SAVAGENT -p tcp -j DROP"
            filter_rules = filter_rules + line + "\n"
            with open(f"{LOG_DIR}/ip4tables_filter_rule.txt", "r") as f:
                lines = f.readlines()[:-2]
            content = ""
            for line in lines:
                content = content + line
            content = content + filter_rules + "COMMIT\n"
            with open(f"{LOG_DIR}/ip4tables_filter_rule.txt", 'w') as f:
                f.write(content)
            apply_filer_talbes_commmand = f"iptables-restore < {LOG_DIR}/ip4tables_filter_rule.txt"
            command_status = self._command_executor(command=apply_filer_talbes_commmand)

    def _enable_ipv6(self, rules, active_app):
        flush_chain_status = subprocess.call(['ip6tables', '-F', SAV_CHAIN])
        if flush_chain_status != 0:
            logger.error(f"flush ip6tables failed")
        interface_set = set(get_host_interface_list())
        # store iptables
        store_init_filer_talbes_commmand = f"ip6tables-save -t filter > {LOG_DIR}/ip6tables_filter_rule.txt"
        command_status = self._command_executor(command=store_init_filer_talbes_commmand)
        filter_rules = ""
        container_id = os.environ.get("HOSTNAME")
        if active_app not in ["EFP-uRPF-Algorithm-A_app", "EFP-uRPF-Algorithm-B_app"]:
            for r in list(rules.values()):
                ip_addr, prefixlen, interface_name = str(r["prefix"].ip), r["prefix"].prefixlen, set((r["interface_name"],))
                for interface in interface_set - interface_name:
                    log_line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface} -j LOG --log-prefix \"IPTABLES {container_id} DROP: \"" + "\n"
                    line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface} -j DROP"
                    filter_rules = filter_rules + log_line  + line + "\n"
            with open(f"{LOG_DIR}/ip6tables_filter_rule.txt", "r") as f:
                lines = f.readlines()[:-2]
            content = ""
            for line in lines:
                content = content + line
            content = content + filter_rules + "COMMIT\n"
            with open(f"{LOG_DIR}/ip6tables_filter_rule.txt", 'w') as f:
                f.write(content)
            apply_filer_talbes_commmand = f"ip6tables-restore < {LOG_DIR}/ip6tables_filter_rule.txt"
            command_status = self._command_executor(command=apply_filer_talbes_commmand)
        # using white list mode for EFP-uRPF
        elif active_app in ["EFP-uRPF-Algorithm-A_app", "EFP-uRPF-Algorithm-B_app"]:
            for r in list(rules.values()):
                ip_addr, prefixlen, interface_name = str(r["prefix"].ip), r["prefix"].prefixlen, r["interface_name"]
                line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface_name} -j ACCEPT"
                filter_rules = filter_rules + line + "\n"
            line = f"-A SAVAGENT -p tcp -j DROP"
            filter_rules = filter_rules + line + "\n"
            with open(f"{LOG_DIR}/ip6tables_filter_rule.txt", "r") as f:
                lines = f.readlines()[:-2]
            content = ""
            for line in lines:
                content = content + line
            content = content + filter_rules + "COMMIT\n"
            with open(f"{LOG_DIR}/ip6tables_filter_rule.txt", 'w') as f:
                f.write(content)
            apply_filer_talbes_commmand = f"ip6tables-restore < {LOG_DIR}/ip6tables_filter_rule.txt"
            command_status = self._command_executor(command=apply_filer_talbes_commmand)
    def tc_enable(self, rules, active_app):
        ipv4_rules, ipv6_rules = self._separate_v4_and_v6_addr(rules=rules)
        self._tc_enable_ipv4(rules=ipv4_rules, active_app=active_app)
        self._tc_enable_ipv6(rules=ipv6_rules, active_app=active_app)
        log_info = f"refresh iptables and tc {active_app} successfully"
        logger.info(log_info)
        return None

    def _tc_enable_ipv4(self, rules, active_app):
        flush_chain_status = subprocess.call(['iptables', '-F', SAV_CHAIN])
        if flush_chain_status != 0:
            logger.error(f"flush ip4tables failed")
        interface_list = get_host_interface_list()
        # store iptables
        store_init_filer_talbes_commmand = f"iptables-save -t filter > {LOG_DIR}/ip4tables_filter_rule.txt"
        command_status = self._command_executor(command=store_init_filer_talbes_commmand)
        filter_rules = ""
        for r in list(rules.values()):
            ip_addr, prefixlen, interface_name = str(r["prefix"].ip), r["prefix"].prefixlen, r["interface_name"]
            tc_handle = interface_list.index(interface_name) + 1
            line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface_name} -j MARK --set-mark {tc_handle}"
            filter_rules = filter_rules + line + "\n"
        with open(f"{LOG_DIR}/ip4tables_filter_rule.txt", "r") as f:
            lines = f.readlines()[:-2]
        content = ""
        for line in lines:
            content = content + line
        content = content + filter_rules + "COMMIT\n"
        with open(f"{LOG_DIR}/ip4tables_filter_rule.txt", 'w') as f:
            f.write(content)
        apply_filer_talbes_commmand = f"iptables-restore < {LOG_DIR}/ip4tables_filter_rule.txt"
        command_status = self._command_executor(command=apply_filer_talbes_commmand)

    def _tc_enable_ipv6(self, rules, active_app):
        flush_chain_status = subprocess.call(['ip6tables', '-F', SAV_CHAIN])
        if flush_chain_status != 0:
            logger.error(f"flush ip6tables failed")
        interface_list = get_host_interface_list()
        # store iptables
        store_init_filer_talbes_commmand = f"ip6tables-save -t filter > {LOG_DIR}/ip6tables_filter_rule.txt"
        command_status = self._command_executor(command=store_init_filer_talbes_commmand)
        filter_rules = ""
        for r in list(rules.values()):
            ip_addr, prefixlen, interface_name = str(r["prefix"].ip), r["prefix"].prefixlen, r["interface_name"]
            tc_handle = interface_list.index(interface_name) + 1
            line = f"-A SAVAGENT -s {ip_addr}/{prefixlen} -i {interface_name} -j MARK --set-mark {tc_handle}"
            filter_rules = filter_rules + line + "\n"
        with open(f"{LOG_DIR}/ip6tables_filter_rule.txt", "r") as f:
            lines = f.readlines()[:-2]
        content = ""
        for line in lines:
            content = content + line
        content = content + filter_rules + "COMMIT\n"
        with open(f"{LOG_DIR}/ip6tables_filter_rule.txt", 'w') as f:
            f.write(content)
        apply_filer_talbes_commmand = f"ip6tables-restore < {LOG_DIR}/ip6tables_filter_rule.txt"
        command_status = self._command_executor(command=apply_filer_talbes_commmand)
