#!/usr/bin/python3
# -*- encoding: utf-8 -*-
'''
@Time    :   2023/01/17 16:04:22
'''
import subprocess
import json
from model import db
from model import SavInformationBase, SavTable


KEY_WORD = "SAVAGENT"


def iptables_command_execute(sender, prefix, neighbor_as, interface, **extra):
    add_rule_status = subprocess.call(
        ['iptables', '-A', KEY_WORD, '!', '-i', interface, '-s', prefix, '-j', 'DROP'])
    print(add_rule_status)


class IPTableManager():
    """
    manage the STB with SQLite and Flask-SQLAlchemy
    generate iptables rules and apply them
    """

    def __init__(self, logger, active_app):
        """
        the rule generated by all apps will be added to DB,
        but only the rule generated by the active app will be applied via iptables
        """
        create_chain_status = subprocess.call(['iptables', '-N', KEY_WORD])
        if create_chain_status != 0:
            return
        self.input_status = subprocess.call(
            ['iptables', '-I', 'INPUT', '-j', KEY_WORD])
        self.forward_status = subprocess.call(
            ['iptables', '-I', 'FORWARD', '-j', KEY_WORD])
        self.logger = logger
        self.active_app = active_app

    def _command_executer(self, command):
        return subprocess.run(command, shell=True, capture_output=True, encoding='utf-8')

    def _get_host_interface_list(self):
        """
        return a list of 'clean' interface names
        """
        command = "ip link|grep -v 'link' | grep -v -E 'docker0|lo' | awk -F: '{ print $2 }' | sed 's/ //g'"
        command_result = self._command_executer(command=command)
        std_out = command_result.stdout
        # self.logger.debug(command_result)
        result = std_out.split("\n")[:-1]
        result = list(map(lambda x: x.split('@')[0], result))
        return result

    def _iptables_command_execute(self, command):
        command_result = self._command_executer(command=command)
        return command_result.returncode

    def add(self, data):
        """
        add a rule to the STB
        currently only add ipv4 and inter-domain rules
        """
        prefix, src_app, interface = data.get(
            "prefix"), data.get("source_app"), data.get("interface")
        if (prefix is None) or (src_app is None) or (interface is None):
            self.logger.error(f"Missing required fields [{data.keys()}]")
            raise ValueError("Missing required field")
        neighbor_as = data.get("neighbor_as")
        interface_list = self._get_host_interface_list()
        interface_list.append("*")
        if interface not in interface_list:
            self.logger.error(
                f"the interface {interface} doesn't exit in the list:{interface_list}")
            raise ValueError("the interface doesn't exit!")
        session = db.session
        if session.query(SavTable).filter(
                SavTable.prefix == prefix,
                SavTable.interface == interface,
                SavTable.source == src_app).count() != 0:
            self.logger.warning("rule exists")
            log_msg = f"SAV RULE EXISTS: {data}"
            # log_msg = f"SAV RULE EXISTS: prefix [{prefix}] can only comes from "
            # log_msg += f"interface_name [{interface}], remote_as [{neighbor_as}]"
            self.logger.info(log_msg)
            return
        sib_row = SavTable(
            prefix=prefix,
            neighbor_as=neighbor_as,
            interface=interface,
            source=src_app,
            direction=None)
        session.add(sib_row)
        session.commit()
        session.close()
        log_msg = f"SAV RULE ADDED: {data}"
        self.logger.info(log_msg)
        if src_app != self.active_app:
            return
       # if session.query(SavTable).filter(
       #         SavTable.prefix == prefix).count() == 0:
       #     interface_list.remove(interface)
       #     self.logger.debug(interface_list)
       #     for drop_interface in interface_list:
       #         command = f"iptables -A {KEY_WORD} -i {drop_interface} -s {prefix} -j DROP"
       #         self.logger.debug(command)
       #         self._iptables_command_execute(command=command)
       # else:
       #     command = f"iptables -L -v -n --line-numbers | grep {interface} | grep {prefix}"
       #     command += "| awk '{ print $1 }' | xargs - I v1  iptables - D "
       #     command += f"{KEY_WORD} v1"
       #     self.logger.debug(command)
       #     self._iptables_command_execute(command=command)
        session = db.session

        log_msg = "IP TABLES CHANGED"
        self.logger.debug(log_msg)
        # store data to DB

    def delete(self, input_id):
        session = db.session
        sib_row = session.query(SavTable).filter(
            SavTable.id == input_id).first()
        prefix, interface = sib_row.prefix, sib_row.interface
        session.delete(sib_row)
        session.commit()
        if session.query(SavTable).filter(
         self.active_app:       SavTable.prefix == prefix).count() == 0:
            command = f"iptables -L -v -n --line-numbers | grep {interface} | grep {prefix}"
            command += " |awk '{ print $1 }' | xargs - I v1  iptables - D "
            command += f"{KEY_WORD} v1"
            self._iptables_command_execute(command=command)
        else:
            command = f"iptables -A {KEY_WORD} -i {interface} -s {prefix} -j DROP"
            self._iptables_command_execute(command=command)
        session.close()
        return {"code": "0000", "message": "success"}

    def read(self):
        session = db.session
        sib_tables = session.query(SavTable).all()
        data = []
        for row in sib_tables:
            data.append({"id": row.id,
                         "prefix": row.prefix,
                         "neighbor_as": row.neighbor_as,
                         "interface": row.interface,
                         "source": row.source,
                         "direction": row.direction,
                         "createtime": row.createtime})
        session.close()
        return data


class SIBManager():
    """
    manage the STB with SQLite and Flask-SQLAlchemy
    generate iptables rules and apply them
    this table stores the key and value of a dictionary object, both key and value must be string
    """

    def __init__(self, logger):

        self.logger = logger

    def upsert(self, key, value):
        """
        add or update a key-value pair in db, both key and value must in string format.
        """
        if not (isinstance(key, str) and isinstance(value, str)):
            raise TypeError("key and value must be string")
        if len(key) > 255 or len(key) < 1:
            raise ValueError(
                "key length must be less than 255 and value length must be greater than 0")
        session = db.session
        row = session.query(SavInformationBase).filter(
            SavInformationBase.key == key).first()
        if row:
            session.delete(row)
        new_row = SavInformationBase(key=key, value=value)
        session.add(new_row)
        session.commit()
        session.close()
        v = json.loads(value)
        msg = f"SIB UPDATED: {key}:"
        if isinstance(v, list):
            for i in v:
                msg += f"\n{i}"
        elif isinstance(v, dict):
            msg += f"\n{json.dumps(v,indent=4)}"
        else:
            msg += f"{v}"
            # self.logger.debug(type(v))
        # self.logger.debug(f"SIB UPDATED: {msg}")

    def delete(self, key):
        session = db.session
        row = session.query(SavInformationBase).filter(
            SavInformationBase.key == key).first()
        session.delete(row)
        session.commit()
        session.close()
        return {"code": "0000", "message": "success"}

    def read_all(self):
        session = db.session
        sib_tables = session.query(SavInformationBase).all()
        data = []
        for row in sib_tables:
            data.append({row.key: row.value})
        session.close()
        return data
